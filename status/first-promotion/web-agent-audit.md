The first promotion proposal was already careful by ordinary standards, but the audit showed that it leaned too much on a narrative of “multiple converging routes” and “status: ok” without enough machinery to make those claims stick, or to sharply delimit what they did and did not cover. The remediation work has mostly been about tightening the epistemic story: making common-mode risks explicit, adding stress tests where the static model could be wrong, and encoding boundaries and demotion paths into the repo so that “bedrock” is a real contract, not just a label.

For the **operation vocabulary**, the original proposal’s story—dyld harvest, op-table experiments, system-profile digests—was roughly right but incomplete. It implicitly treated 196 ops as both complete and uniformly well-supported. The audit surfaced several gaps: (1) a common-mode risk that a single bad dyld/libsandbox slice or misidentified `_operation_names` table could poison `ops.json`, op-table alignment, and digests together; (2) no way to distinguish operations with runtime evidence from those that were “name+ID only”; and (3) a tendency to talk about “independent routes” when everything still flowed through one decoder and one set of binary slices. The remediations address those directly: a manifest + guardrail for the trimmed dyld slices, so the source table is pinned and any drift is loud; an adversarial runtime suite that exercises file-read*, file-write*, and mach-lookup under deliberately tricky profiles to check static↔runtime alignment; and `ops_coverage.json` to mark which ops have structural vs runtime evidence. The underlying intellectual claim—“for this world, these 196 names and IDs describe the libsandbox operation table the kernel actually sees”—is now backed by explicit contracts about where the table comes from, how stable it is, and which parts of it have been behaviorally exercised.

For the **modern profile format and tag layouts**, the original proposal compressed a lot into the phrase “modern-heuristic” and treated a small set of literal/regex tags as “structural facts” largely on the strength of decoder inference plus a libsandbox-encoder check. The audit showed two weaknesses: (1) the distinction between “layout is bedrock” and “semantics are still partly heuristic” was not made explicit, and (2) the scope of the claim (a handful of tags) was easy to misread as covering “tag layouts” in general. There was also no tight coupling between canonical profile status and tag-layout demotion. The remediation passes have turned this into a narrower but more defensible claim: `tag_layouts.json` explicitly lists the covered tags; hash-based tests enforce that only metadata changes can leave the contract hash untouched; canonical profile status is propagated into tag-layout metadata so drift demotes layouts automatically; and docs now say, in effect, “for these tags, the 12-byte layout (sizes and offsets) is bedrock, established independently from blob-side decoder inference and compiler-side emission; beyond that, unknown tags are stride-12 and semantics are still heuristic.” The intellectual move is now: we are not asserting a global theorem about all tags; we are freezing a carefully evidenced subset of layouts and treating them as fixed inputs to downstream tools.

For the **canonical system profiles**, the original proposal claimed that `sys:airlock`, `sys:bsd`, and `sys:sample` were faithful, stable summaries of Apple’s shipped SBPL and used them as a heavy anchor for everything from tag layouts to coverage indices. It pointed at digests, static checks, and attestations, and gestured at runtime experiments, but the audit exposed three key issues: (1) there was no mechanical demotion path—profile drift would be noticed only if a human paid attention to diffs; (2) static checks and digests were both built on the same decoder/ingestion stack, so their “independence” was partly illusory; and (3) apply-gated profiles like `sys:airlock` could not be validated end-to-end at runtime, yet were still treated as bedrock about kernel behavior. The remediation work has tightened this considerably: contracts now bundle blob SHA/size, op-table hash/len, tag counts, tag-layout hash, and world pointer; tests assert those contract fields and enforce that any drift flips status to `brittle` and propagates into tag layouts and coverage; attestations provide a separately implemented walk over literals and anchors; CARTON carries the hashes; and the docs now say plainly that bedrock here is “what blobs the kernel consumes for these profiles, and what their decoded structure is,” not “what we have exhaustively tested at runtime.” That is a smaller claim, but it is clear and mechanically enforced.

The other big arc in the audit was about **static IR versus runtime behavior**. The original proposal’s cross-check story was essentially: “Apple artifacts + our SBPL/decoder route agree, and some runtime harnesses behave as expected, so static IR is a good proxy for what the sandbox sees.” The audit called this out as too friendly: there were no adversarial profiles designed to break the alignment, and the kernel was treated as a black box without a clear plan for how to catch subtle misinterpretations. The runtime-adversarial suite, plus its explicit “Claims and limits” section, changes that: for a specific set of operations and shapes (file-read*/file-write* buckets, mach-lookup with global/local literals and regex, plus structural/metafilter variants), the project has now tried to construct profiles that might expose discrepancies and found none, while explicitly classifying the only mismatch (`/tmp`→`/private/tmp`) as a VFS effect outside the PolicyGraph model. That is exactly the kind of evidence the first proposal gestured at but did not actually have.

Finally, the audit pushed the project to make its **boundaries and standards** explicit. The first proposal spoke of “independent routes,” “status: ok,” and “bedrock” in a way that could easily be over-read as a global guarantee. The remediation pass has forced a tighter definition: bedrock is scoped to a single, named world; it is “canonical under the current single decoder and ingestion stack,” not backed by a second implementation; it is limited to specific tags, operations, and profiles; and it comes with a documented demotion story and machine-readable coverage indicators. The intellectual claims have become both richer (more explicit about what evidence exists and how it fits together) and more rigid (encoding contracts, guardrails, and failure modes into the repo), while also being more modest in scope.

So, backed out: the main issues with the first promotion report were overstatement of independence, lack of mechanical demotion and drift enforcement, insufficient runtime stress testing, and fuzzy boundaries around what “bedrock” meant and what it covered. The post-remediation state is not perfect—there is still one decoder, many operations are still structurally but not behaviorally evidenced, unknown tags remain heuristic—but those limitations are now first-class, and the core claims about vocab, tag layouts for a specified subset, and canonical system profiles for this world are anchored in a much clearer, safer evidentiary story.
