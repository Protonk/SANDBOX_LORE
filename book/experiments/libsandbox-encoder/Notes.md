- Initialized experiment scaffolding; phases and deliverables captured in Plan.md.
- Pulled web-model heuristics for Phase B: anchor on the profile buffer allocator/serializer in `libsandbox` (buffer passed to `__mac_syscall`), find the node-emission loop and `strh` at the known `field2` offset, and backtrack through `_filter_info` consumers and TinyScheme primitive table xrefs (strings like `allow`, `deny`, `literal`, `regex`, `subpath`) to per-filter helpers that intern args (literal/regex/number) before serialization. Expect primitive tables and `_filter_info` to remain flat arrays (PAC stubs aside) inside `libsandbox`, with `libsystem_sandbox` as API glue only.
- Phase A sketch: target operations `file-read*`, `mach-lookup`, `network-outbound`; filter/arg shapes to probe include literal path, subpath, regex path (if the compiler accepts it), socket domain/type/proto triples, iokit class/property, mach names/anchors. Plan to record `(op, filter_name, SBPL arg text, filter_id from filters.json, tag, raw field2)` in `out/field2_encoder_matrix.json` and explicitly check for mismatches/high codes (16660, 2560, 0xffff, 3584, 10752).
- Implemented Phase A matrix v1 (regex-free) in `sb/matrix_v1.sb`: file-read* with literal/subpath, mach-lookup with global/local names, network-outbound with socket domain/type/proto, iokit-open with registry-entry-class/property. Regex probes deferred to a follow-up matrix to keep the baseline clean.
- Filter vocab references for planned probes (from `filters.json`): `path`=0, `global-name`=5, `local-name`=6, `socket-domain`=10, `socket-type`=11, `socket-protocol`=12, `iokit-registry-entry-class`=16, `iokit-property`=17.
- Added `run_phase_a.py` helper (profile_ingestion + decoder) to compile `matrix_v1`, slice nodes, and emit `out/field2_encoder_matrix.json`. Updated to load local tag-layout overrides and skip tags without payloads; literal_refs still attached heuristically.
- Staged local tag-layout overrides in `out/tag_layout_overrides.json` (priority over published mappings): tag3/tag8 payload at field[2]; tag2/tag10 provisional (record_size 12, payload field[2] for tag10, none for tag2).
- Phase A v1 observations (after overrides):
  - Header op_count=11; node_count=33 (tags {10,8,4,0,6,3}, remainder 3 bytes). Payload extraction now uses tag-specific layouts.
  - field2 values are all mapped to vocab IDs: socket-domain (10) dominates tag10 nodes; remote (8), control-name (9), local-name (6) appear on a few nodes with matching literal refs. No unknown/high codes surfaced in this pass.
  - Literal refs surface the injected strings (`/tmp/encoder/*`, mach names, iokit strings); nodes carrying literals now align with filter IDs instead of collapsing to socket-domain everywhere.
- Slicing sanity via inspect_profile: tiny profiles (`single_file_literal/subpath`, `single_network_domain`) have nodes_start/literal_start aligned (e.g., nodes_start=22, literal_start=369 for single_file_literal). Despite correct slicing, tag2/tag3 dominate those tiny profiles with constant field values, suggesting meta/scaffolding rather than filter nodes.
- Quick tag inventory check (existing `tag_inventory.json` + tiny blobs): tag2 and tag3 appear in many profiles with counts fixed per stride (often 1 per op or header-like) and fields stable; no evidence they vary with SBPL args. Leaning toward marking tag2/tag3 as meta (no payload) in local overrides and excluding them from the encoder matrix; tag10/8/6/9 remain the active filter-bearing tags.
- Updated local overrides to mark tag2/tag3 as meta/no payload, reran Phase A: `field2_encoder_matrix.json` now only includes tags with payloads (10/8/6/9). Next focus: differentiate filter-ID vs payload fields for tags 10/8/6/9 across existing profiles without adding new probes.
